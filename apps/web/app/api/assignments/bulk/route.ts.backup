// TrueNamePath: Bulk Context Assignments API Route
// POST /api/assignments/bulk - Bulk update context-name assignments
// Date: August 14, 2025
// Academic project REST API with authentication and validation

// TrueNamePath: Bulk Context Assignments API Route
// POST /api/assignments/bulk - Bulk update context-name assignments
// Date: August 20, 2025
// Academic project REST API with authentication and validation

import { NextRequest } from 'next/server';
import type {
  AssignmentWithDetails,
  BulkAssignmentResponseData,
  OIDCPropertyType,
} from '../types';
import {
  BulkAssignmentRequestSchema,
  createBulkValidationErrorResponse as sharedCreateBulkValidationErrorResponse,
} from '../schemas';
import {
  withRequiredAuth,
  createSuccessResponse,
  createErrorResponse,
  handle_method_not_allowed,
  type AuthenticatedHandler,
  type AuthenticatedContext,
  validate_authenticated_user,
  handle_database_error,
} from '@/utils/api';
import { ErrorCodes } from '@/utils/api';
import { z } from 'zod';
// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Validates and parses the bulk assignment request body
 */
function validateBulkAssignmentRequest(body: unknown) {
  return BulkAssignmentRequestSchema.safeParse(body);
}

/**
 * Creates a standardized validation error response for bulk operations using shared helper
 */
function createBulkValidationErrorResponse(
  result: { error: z.ZodError },
  requestId: string,
  timestamp: string,
) {
  return sharedCreateBulkValidationErrorResponse(
result,
requestId,
timestamp,
createErrorResponse,
ErrorCodes,
  );
}

/**
 * POST handler implementation for bulk assignment operations
 */
const bulkUpdateAssignments = async (
  request: NextRequest,
  context: AuthenticatedContext,
) => {
  const { supabase, user, requestId, timestamp } = context;
  try {
// Parse and validate request body
const body = await request.json();
const body_result = validateBulkAssignmentRequest(body);

if (!body_result.success) {
  return createBulkValidationErrorResponse(
{ error: body_result.error },
requestId,
timestamp,
  );
}

const { assignments } = body_result.data;

// Validate user authentication
const user_validation = validate_authenticated_user(
  user,
  requestId,
  timestamp,
);
if ('error' in user_validation) {
  return user_validation.error;
}

const { authenticated_user_id } = user_validation;

// Validate all context_ids belong to the user
const context_ids = assignments.map((a) => a.context_id);
const { data: user_contexts, error: context_error } = await supabase
  .from('user_contexts')
  .select('id')
  .eq('user_id', authenticated_user_id)
  .in('id', context_ids);

if (context_error) {
  return handle_database_error(
context_error,
'Context validation',
requestId,
timestamp,
'Failed to validate user contexts',
  );
}

const valid_context_ids = new Set(user_contexts.map((c) => c.id));
const invalid_contexts = context_ids.filter(
  (id) => !valid_context_ids.has(id),
);

if (invalid_contexts.length > 0) {
  return createErrorResponse(
ErrorCodes.FORBIDDEN,
'Some contexts do not belong to the user',
requestId,
{ invalid_context_ids: invalid_contexts },
timestamp,
  );
}

// Validate all name_ids belong to the user (when not null)
const name_ids = assignments
  .map((a) => a.name_id)
  .filter((id): id is string => id !== null);

if (name_ids.length > 0) {
  const { data: user_names, error: name_error } = await supabase
.from('names')
.select('id')
.eq('user_id', authenticated_user_id)
.in('id', name_ids);

  if (name_error) {
return handle_database_error(
  name_error,
  'Name validation',
  requestId,
  timestamp,
  'Failed to validate user names',
);
  }

  const valid_name_ids = new Set(user_names.map((n) => n.id));
  const invalid_names = name_ids.filter((id) => !valid_name_ids.has(id));

  if (invalid_names.length > 0) {
return createErrorResponse(
  ErrorCodes.FORBIDDEN,
  'Some names do not belong to the user',
  requestId,
  { invalid_name_ids: invalid_names },
  timestamp,
);
  }
}

// Pre-filter assignments to identify only those that represent actual changes
console.log(
  `[${requestId}] Starting pre-filtering of ${assignments.length} assignments`,
);

const { data: existing_assignments, error: existing_error } = await supabase
  .from('context_name_assignments')
  .select('context_id, name_id')
  .eq('user_id', authenticated_user_id)
  .in('context_id', context_ids);

if (existing_error) {
  console.error('Error fetching existing assignments:', existing_error);
  return createErrorResponse(
ErrorCodes.DATABASE_ERROR,
'Failed to fetch existing assignments',
requestId,
{ error: existing_error.message },
timestamp,
  );
}

// Create a map of existing assignments for quick lookup
const existing_assignment_map = new Map<string, string | null>();
existing_assignments.forEach((existing) => {
  existing_assignment_map.set(existing.context_id, existing.name_id);
});

// Filter assignments to process only those that represent actual changes
const assignments_to_process = assignments.filter((assignment) => {
  const { context_id, name_id } = assignment;
  const existing_name_id = existing_assignment_map.get(context_id);

  // Case 1: Deleting assignment (name_id = null)
  if (name_id === null) {
const should_delete = existing_name_id !== undefined; // Assignment exists and should be deleted
if (!should_delete) {
  console.log(
`[${requestId}] Filtered out deletion for context ${context_id} - no existing assignment`,
  );
}
return should_delete;
  }

  // Case 2: Creating/updating assignment (name_id is not null)
  const should_process = existing_name_id !== name_id; // Different from existing or new assignment
  if (!should_process) {
console.log(
  `[${requestId}] Filtered out assignment for context ${context_id} - name_id already set to ${name_id}`,
);
  }
  return should_process;
});

console.log(
  `[${requestId}] Pre-filtering complete: ${assignments_to_process.length}/${assignments.length} assignments will be processed`,
);
console.log(
  `[${requestId}] Filtered assignments:`,
  assignments_to_process.map((a) => `${a.context_id}:${a.name_id}`),
);

// Process bulk assignment updates (only for filtered assignments)
let created = 0;
let updated = 0;
let deleted = 0;

for (const assignment of assignments_to_process) {
  const { context_id, name_id } = assignment;

  if (name_id === null) {
// Delete assignment (only processed if assignment actually exists)
console.log(
  `[${requestId}] Deleting assignment for context ${context_id}`,
);
const { error: delete_error } = await supabase
  .from('context_name_assignments')
  .delete()
  .eq('user_id', authenticated_user_id)
  .eq('context_id', context_id);

if (delete_error) {
  console.error(
`[${requestId}] Delete assignment error for context ${context_id}:`,
delete_error,
  );
  // Continue processing other assignments
} else {
  deleted++;
  console.log(
`[${requestId}] Successfully deleted assignment for context ${context_id}`,
  );
}
  } else {
// Determine if this is an update or create based on existing assignment map
const existing_name_id = existing_assignment_map.get(context_id);
const is_update = existing_name_id !== undefined;

console.log(
  `[${requestId}] ${is_update ? 'Updating' : 'Creating'} assignment for context ${context_id} with name ${name_id}`,
);

// Upsert assignment (update or create)
// Use 'context_id' as conflict column since database has UNIQUE (context_id) constraint
const { error: upsert_error } = await supabase
  .from('context_name_assignments')
  .upsert(
{
  user_id: authenticated_user_id,
  context_id,
  name_id,
  created_at: new Date().toISOString(),
},
{
  onConflict: 'context_id',
},
  );

if (upsert_error) {
  console.error(
`[${requestId}] Upsert assignment error for context ${context_id}:`,
upsert_error,
  );
  // Continue processing other assignments
} else {
  // Track based on pre-filtering determination
  if (is_update) {
updated++;
console.log(
  `[${requestId}] Successfully updated assignment for context ${context_id}`,
);
  } else {
created++;
console.log(
  `[${requestId}] Successfully created assignment for context ${context_id}`,
);
  }
}
  }
}

// Log processing summary
console.log(
  `[${requestId}] Bulk assignment processing complete: ${created} created, ${updated} updated, ${deleted} deleted`,
);

// Get all current assignments for response
const { data: final_assignments, error: final_error } = await supabase
  .from('context_name_assignments')
  .select(
`
id,
context_id,
name_id,
created_at,
user_contexts!inner(
  context_name
),
names!inner(
  name_text,
  oidc_property_type
)
  `,
  )
  .eq('user_id', authenticated_user_id)
  .order('created_at', { ascending: false });

if (final_error) {
  console.error('Final assignments query error:', final_error);
  return createErrorResponse(
ErrorCodes.DATABASE_ERROR,
'Failed to retrieve updated assignments',
requestId,
{ error: final_error.message },
timestamp,
  );
}

// Process final assignments data
const assignment_results: AssignmentWithDetails[] = final_assignments.map(
  (item: {
id: string;
context_id: string;
name_id: string;
created_at: string;
user_contexts: { context_name: string };
names: {
  name_text: string;
  oidc_property_type: OIDCPropertyType | null;
};
  }) => ({
id: item.id,
context_id: item.context_id,
context_name: item.user_contexts.context_name,
context_description: null, // Not fetched in bulk endpoint
name_id: item.name_id,
name_text: item.names.name_text,
name_type: item.names.oidc_property_type,
created_at: item.created_at,
  }),
);

// Prepare response data
const response_data: BulkAssignmentResponseData = {
  updated,
  created,
  deleted,
  assignments: assignment_results,
};

return createSuccessResponse(response_data, requestId, timestamp);
  } catch (error) {
console.error('Unexpected error in bulk assignment operation:', error);
return createErrorResponse(
  ErrorCodes.INTERNAL_SERVER_ERROR,
  'An unexpected error occurred during bulk assignment operation',
  requestId,
  { error: String(error) },
  timestamp,
);
  }
};

/**
 * Export the POST handler with authentication wrapper
 */
export const POST = withRequiredAuth(
  bulkUpdateAssignments as AuthenticatedHandler,
);

// Method not allowed handlers
export const GET = () => handle_method_not_allowed(['POST']);
export const PUT = () => handle_method_not_allowed(['POST']);
export const DELETE = () => handle_method_not_allowed(['POST']);
export const PATCH = () => handle_method_not_allowed(['POST']);
