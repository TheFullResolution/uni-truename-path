// TrueNamePath: Comprehensive Unit Tests for withAuth Higher-Order Function
// Tests authentication wrapper with full coverage of scenarios and edge cases
// Date: August 12, 2025
// Academic project - comprehensive test coverage for breaking changes implementation

// Note: Using standard Jest globals - @jest/globals not available in this environment
import { NextRequest, NextResponse } from 'next/server';
import { 
  withAuth, 
  withRequiredAuth, 
  withOptionalAuth, 
  createSuccessResponse, 
  createErrorResponse,
  type AuthenticatedHandler,
  type AuthenticatedContext,
  type StandardSuccessResponse,
  type StandardErrorResponse 
} from './with-auth';
import { apiAuth, type AuthenticatedUser } from '@uni-final-project/database';

// Mock the database module
jest.mock('@uni-final-project/database', () => ({
  apiAuth: {
authenticateRequest: jest.fn(),
  },
}));

const mockApiAuth = apiAuth as jest.Mocked<typeof apiAuth>;

describe('withAuth Higher-Order Function', () => {
  // Test data constants
  const MOCK_USER: AuthenticatedUser = {
id: 'user-123',
email: 'test@example.com',
profile: {
  id: 'profile-456',
  user_id: 'user-123',
  full_name: 'Test User',
  created_at: '2025-01-12T10:00:00.000Z',
  updated_at: '2025-01-12T10:00:00.000Z',
  preferred_name_id: null,
} as any, // Simplified for testing
  };

  const MOCK_REQUEST_URL = 'http://localhost:3000/api/test';

  // Helper function to create mock NextRequest
  const createMockRequest = (options: {
method?: string;
headers?: Record<string, string>;
url?: string;
  } = {}): NextRequest => {
const {
  method = 'GET',
  headers = {},
  url = MOCK_REQUEST_URL,
} = options;

const request = new NextRequest(url, {
  method,
  headers: new Headers(headers),
});

return request;
  };

  // Helper function to create a simple test handler
  const createTestHandler = (
response: StandardSuccessResponse<any> | StandardErrorResponse,
  ): AuthenticatedHandler => {
return jest.fn(async (request, context) => response);
  };

  beforeEach(() => {
jest.clearAllMocks();
// Reset environment to test mode (use Object.defineProperty for read-only properties)
Object.defineProperty(process.env, 'NODE_ENV', {
  value: 'test',
  writable: true,
  configurable: true,
});
  });

  describe('Required Authentication Mode', () => {
test('should successfully authenticate valid user', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const successData = { message: 'Success', userId: MOCK_USER.id };
  const handler = createTestHandler(
createSuccessResponse(successData, 'test-req-id')
  );

  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer valid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(200);
  expect(mockApiAuth.authenticateRequest).toHaveBeenCalledWith(request.headers);
  expect(handler).toHaveBeenCalledWith(
request,
expect.objectContaining({
  user: MOCK_USER,
  isAuthenticated: true,
  requestId: expect.stringMatching(/^req_\d+_[a-z0-9]{9}$/),
  timestamp: expect.any(String),
})
  );

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: true,
data: successData,
requestId: expect.any(String),
timestamp: expect.any(String),
  });
});

test('should reject missing authorization token', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_REQUIRED',
  message: 'Missing authorization token',
},
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest(); // No auth header

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(401);
  expect(handler).not.toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: 'AUTHENTICATION_REQUIRED',
  message: 'Missing authorization token',
  requestId: expect.any(String),
  timestamp: expect.any(String),
},
  });
});

test('should reject invalid JWT token', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_FAILED',
  message: 'Invalid JWT token signature',
},
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer invalid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(401);
  expect(handler).not.toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: 'AUTHENTICATION_FAILED',
  message: 'Invalid JWT token signature',
  requestId: expect.any(String),
  timestamp: expect.any(String),
},
  });
});

test('should handle authentication service errors gracefully', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'TOKEN_VERIFICATION_FAILED',
  message: 'Token verification service unavailable',
},
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer token-service-error' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(401);
  expect(handler).not.toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: 'TOKEN_VERIFICATION_FAILED',
  message: 'Token verification service unavailable',
  requestId: expect.any(String),
  timestamp: expect.any(String),
},
  });
});

test('should use custom error handler when provided', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_REQUIRED',
  message: 'Missing token',
},
  });

  const customErrorHandler = jest.fn(() => ({
success: false as const,
error: {
  code: 'CUSTOM_AUTH_ERROR',
  message: 'Custom authentication failed',
  requestId: 'custom-req-id',
  timestamp: new Date().toISOString(),
},
  }));

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, {
authMode: 'required',
onAuthError: customErrorHandler,
  });
  const request = createMockRequest();

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(401);
  expect(customErrorHandler).toHaveBeenCalledWith(
{
  code: 'AUTHENTICATION_REQUIRED',
  message: 'Missing token',
},
expect.any(String)
  );

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: 'CUSTOM_AUTH_ERROR',
  message: 'Custom authentication failed',
},
  });
});
  });

  describe('Optional Authentication Mode', () => {
test('should process authenticated requests with user context', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const handler = jest.fn(async (request: NextRequest, context: AuthenticatedContext) => {
expect(context.isAuthenticated).toBe(true);
expect(context.user).toEqual(MOCK_USER);
return createSuccessResponse(
  { message: `Hello ${context.user?.email}` },
  context.requestId
);
  });

  const wrappedHandler = withAuth(handler, { authMode: 'optional' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer valid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(200);
  expect(handler).toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse.data.message).toBe(`Hello ${MOCK_USER.email}`);
});

test('should process unauthenticated requests without user context', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_REQUIRED',
  message: 'Missing authorization token',
},
  });

  const handler = jest.fn(async (request: NextRequest, context: AuthenticatedContext) => {
expect(context.isAuthenticated).toBe(false);
expect(context.user).toBeNull();
return createSuccessResponse(
  { message: 'Hello anonymous user' },
  context.requestId
);
  });

  const wrappedHandler = withAuth(handler, { authMode: 'optional' });
  const request = createMockRequest(); // No auth header

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(200);
  expect(handler).toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse.data.message).toBe('Hello anonymous user');
});

test('should handle invalid tokens gracefully in optional mode', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_FAILED',
  message: 'Invalid JWT token',
},
  });

  const handler = jest.fn(async (request: NextRequest, context: AuthenticatedContext) => {
// In optional mode, authentication failure should not block execution
expect(context.isAuthenticated).toBe(false);
expect(context.user).toBeNull();
return createSuccessResponse(
  { message: 'Processed without authentication' },
  context.requestId
);
  });

  const wrappedHandler = withAuth(handler, { authMode: 'optional' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer invalid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(200);
  expect(handler).toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse.data.message).toBe('Processed without authentication');
});
  });

  describe('HTTP Status Code Mapping', () => {
test.each([
  ['VALIDATION_ERROR', 400],
  ['INVALID_JSON', 400],
  ['INVALID_REQUEST', 400],
  ['AUTHENTICATION_REQUIRED', 401],
  ['AUTHENTICATION_FAILED', 401],
  ['TOKEN_VERIFICATION_FAILED', 401],
  ['AUTHORIZATION_ERROR', 403],
  ['FORBIDDEN', 403],
  ['NOT_FOUND', 404],
  ['RESOURCE_NOT_FOUND', 404],
  ['METHOD_NOT_ALLOWED', 405],
  ['CONFLICT', 409],
  ['DUPLICATE_RESOURCE', 409],
  ['INTERNAL_SERVER_ERROR', 500],
  ['DATABASE_ERROR', 500],
  ['NETWORK_ERROR', 500],
  ['TIMEOUT_ERROR', 504],
  ['UNKNOWN_ERROR', 500], // Default fallback
])('should map error code %s to HTTP status %d', async (errorCode, expectedStatus) => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const errorResponse = createErrorResponse(
errorCode,
`Test error for ${errorCode}`,
'test-req-id'
  );

  const handler = createTestHandler(errorResponse);
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer valid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(expectedStatus);

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: errorCode,
  message: `Test error for ${errorCode}`,
},
  });
});
  });

  describe('Request ID and Logging', () => {
test('should generate unique request IDs', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });

  // Act - make multiple requests
  const request1 = createMockRequest({ headers: { Authorization: 'Bearer token1' } });
  const request2 = createMockRequest({ headers: { Authorization: 'Bearer token2' } });

  const [response1, response2] = await Promise.all([
wrappedHandler(request1),
wrappedHandler(request2),
  ]);

  // Assert
  const json1 = await response1.json();
  const json2 = await response2.json();

  expect(json1.requestId).toMatch(/^req_\d+_[a-z0-9]{9}$/);
  expect(json2.requestId).toMatch(/^req_\d+_[a-z0-9]{9}$/);
  expect(json1.requestId).not.toBe(json2.requestId);
});

test('should include request ID in response headers', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer valid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  const requestIdHeader = response.headers.get('X-Request-ID');
  expect(requestIdHeader).toMatch(/^req_\d+_[a-z0-9]{9}$/);

  const jsonResponse = await response.json();
  expect(jsonResponse.requestId).toBe(requestIdHeader);
});

test('should enable logging in development mode', async () => {
  // Arrange
  Object.defineProperty(process.env, 'NODE_ENV', {
value: 'development',
writable: true,
configurable: true,
  });
  const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
method: 'POST',
headers: { 
  Authorization: 'Bearer valid-token',
  'User-Agent': 'Test User Agent for Logging',
},
  });

  // Act
  await wrappedHandler(request);

  // Assert
  expect(consoleSpy).toHaveBeenCalledWith(
expect.stringContaining('API Request'),
expect.objectContaining({
  method: 'POST',
  url: MOCK_REQUEST_URL,
  authMode: 'required',
  userAgent: expect.stringContaining('Test User Agent'),
})
  );

  expect(consoleSpy).toHaveBeenCalledWith(
expect.stringContaining('API Success'),
expect.objectContaining({
  authenticated: true,
  userId: expect.stringContaining(MOCK_USER.id.substring(0, 8)),
  responseType: 'success',
})
  );

  consoleSpy.mockRestore();
});

test('should log authentication warnings', async () => {
  // Arrange
  const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_FAILED',
  message: 'Invalid token signature',
},
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { 
authMode: 'required',
enableLogging: true, // Explicitly enable logging
  });
  const request = createMockRequest({
headers: { Authorization: 'Bearer invalid-token' },
  });

  // Act
  await wrappedHandler(request);

  // Assert
  expect(consoleSpy).toHaveBeenCalledWith(
expect.stringContaining('API Auth Failure'),
expect.objectContaining({
  code: 'AUTHENTICATION_FAILED',
  message: 'Invalid token signature',
})
  );

  consoleSpy.mockRestore();
});
  });

  describe('Error Handling', () => {
test('should handle unexpected errors in authentication wrapper', async () => {
  // Arrange
  const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
  
  // Mock apiAuth to throw an unexpected error
  mockApiAuth.authenticateRequest.mockRejectedValue(
new Error('Unexpected authentication service failure')
  );

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(500);
  expect(handler).not.toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: 'INTERNAL_SERVER_ERROR',
  message: 'Internal server error occurred',
  requestId: expect.any(String),
  timestamp: expect.any(String),
},
  });

  expect(consoleErrorSpy).toHaveBeenCalledWith(
expect.stringContaining('API Wrapper Error'),
expect.objectContaining({
  error: 'Unexpected authentication service failure',
  stack: expect.any(String),
  url: MOCK_REQUEST_URL,
})
  );

  consoleErrorSpy.mockRestore();
});

test('should include error details in development mode', async () => {
  // Arrange
  Object.defineProperty(process.env, 'NODE_ENV', {
value: 'development',
writable: true,
configurable: true,
  });
  jest.spyOn(console, 'error').mockImplementation();

  mockApiAuth.authenticateRequest.mockRejectedValue(
new Error('Development error details')
  );

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest();

  // Act
  const response = await wrappedHandler(request);

  // Assert
  const jsonResponse = await response.json();
  expect(jsonResponse.error.details).toEqual({
message: 'Development error details',
  });
});

test('should hide error details in production mode', async () => {
  // Arrange
  Object.defineProperty(process.env, 'NODE_ENV', {
value: 'production',
writable: true,
configurable: true,
  });
  jest.spyOn(console, 'error').mockImplementation();

  mockApiAuth.authenticateRequest.mockRejectedValue(
new Error('Production error that should be hidden')
  );

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest();

  // Act
  const response = await wrappedHandler(request);

  // Assert
  const jsonResponse = await response.json();
  expect(jsonResponse.error.details).toBeUndefined();
});
  });

  describe('Response Headers', () => {
test('should set standard response headers', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: 'Bearer valid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.headers.get('Content-Type')).toBe('application/json');
  expect(response.headers.get('Cache-Control')).toBe('no-cache, no-store, must-revalidate');
  expect(response.headers.get('X-Request-ID')).toMatch(/^req_\d+_[a-z0-9]{9}$/);
});
  });

  describe('Convenience Wrapper Functions', () => {
test('withRequiredAuth should work as shorthand for required mode', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: MOCK_USER,
error: null,
  });

  const handler = createTestHandler(createSuccessResponse({ test: 'data' }, 'test-req-id'));
  const wrappedHandler = withRequiredAuth(handler);
  const request = createMockRequest({
headers: { Authorization: 'Bearer valid-token' },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(200);
  const jsonResponse = await response.json();
  expect(jsonResponse.success).toBe(true);
});

test('withOptionalAuth should work as shorthand for optional mode', async () => {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: { code: 'AUTHENTICATION_REQUIRED', message: 'No token' },
  });

  const handler = createTestHandler(createSuccessResponse({ test: 'data' }, 'test-req-id'));
  const wrappedHandler = withOptionalAuth(handler);
  const request = createMockRequest(); // No auth header

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(200);
  const jsonResponse = await response.json();
  expect(jsonResponse.success).toBe(true);
});
  });

  describe('Helper Functions', () => {
test('createSuccessResponse should format responses correctly', () => {
  // Act
  const response = createSuccessResponse(
{ userId: 'test-123', name: 'Test User' },
'req-456',
'2025-01-12T10:00:00.000Z'
  );

  // Assert
  expect(response).toEqual({
success: true,
data: { userId: 'test-123', name: 'Test User' },
requestId: 'req-456',
timestamp: '2025-01-12T10:00:00.000Z',
  });
});

test('createErrorResponse should format error responses correctly', () => {
  // Act
  const response = createErrorResponse(
'VALIDATION_ERROR',
'Invalid input parameters',
'req-789',
{ field: 'email', issue: 'invalid format' },
'2025-01-12T10:00:00.000Z'
  );

  // Assert
  expect(response).toEqual({
success: false,
error: {
  code: 'VALIDATION_ERROR',
  message: 'Invalid input parameters',
  details: { field: 'email', issue: 'invalid format' },
  requestId: 'req-789',
  timestamp: '2025-01-12T10:00:00.000Z',
},
  });
});

test('helper functions should auto-generate timestamps', () => {
  // Arrange
  const beforeTime = new Date().toISOString();

  // Act
  const successResponse = createSuccessResponse({}, 'req-1');
  const errorResponse = createErrorResponse('TEST_ERROR', 'Test message', 'req-2');

  const afterTime = new Date().toISOString();

  // Assert
  expect(successResponse.timestamp).toBeGreaterThanOrEqual(beforeTime);
  expect(successResponse.timestamp).toBeLessThanOrEqual(afterTime);
  expect(errorResponse.error.timestamp).toBeGreaterThanOrEqual(beforeTime);
  expect(errorResponse.error.timestamp).toBeLessThanOrEqual(afterTime);
});
  });
});

describe('Enhanced Auth Edge Cases', () => {
  beforeEach(() => {
jest.clearAllMocks();
  });

  test('should handle expired JWT tokens', async () => {
// Arrange
mockApiAuth.authenticateRequest.mockResolvedValue({
  user: null,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'JWT token has expired',
  },
});

const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
const wrappedHandler = withAuth(handler, { authMode: 'required' });
const request = createMockRequest({
  headers: { Authorization: 'Bearer expired.jwt.token.here' },
});

// Act
const response = await wrappedHandler(request);

// Assert
expect(response.status).toBe(401);
expect(handler).not.toHaveBeenCalled();

const jsonResponse = await response.json();
expect(jsonResponse).toMatchObject({
  success: false,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'JWT token has expired',
requestId: expect.any(String),
timestamp: expect.any(String),
  },
});
  });

  test('should handle malformed JWT tokens (invalid format)', async () => {
// Arrange - Test various malformed JWT formats
const malformedTokens = [
  'not-a-jwt-at-all',
  'missing.middle',
  'too.many.parts.in.this.jwt.token',
  'invalid-base64-encoding!@#$%',
  'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9', // Missing parts
  '', // Empty token
];

for (const malformedToken of malformedTokens) {
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_FAILED',
  message: 'Malformed JWT token format',
},
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: { Authorization: `Bearer ${malformedToken}` },
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(401);
  expect(handler).not.toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse).toMatchObject({
success: false,
error: {
  code: 'AUTHENTICATION_FAILED',
  message: 'Malformed JWT token format',
  requestId: expect.any(String),
  timestamp: expect.any(String),
},
  });
}
  });

  test('should handle valid token with deleted/non-existent user', async () => {
// Arrange - JWT is valid but user no longer exists
mockApiAuth.authenticateRequest.mockResolvedValue({
  user: null,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'User account not found or has been deleted',
  },
});

const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
const wrappedHandler = withAuth(handler, { authMode: 'required' });
const request = createMockRequest({
  headers: { Authorization: 'Bearer valid-jwt-but-deleted-user' },
});

// Act
const response = await wrappedHandler(request);

// Assert
expect(response.status).toBe(401);
expect(handler).not.toHaveBeenCalled();

const jsonResponse = await response.json();
expect(jsonResponse).toMatchObject({
  success: false,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'User account not found or has been deleted',
requestId: expect.any(String),
timestamp: expect.any(String),
  },
});
  });

  test('should handle missing profile scenarios', async () => {
// Arrange - User exists but profile is missing
const userWithoutProfile: AuthenticatedUser = {
  id: 'user-456',
  email: 'no-profile@test.com',
  profileId: null, // Missing profile
};

mockApiAuth.authenticateRequest.mockResolvedValue({
  user: userWithoutProfile,
  error: null,
});

const handler = jest.fn(async (req: NextRequest, context: AuthenticatedContext) => {
  // Handler should still work but be aware profile might be null
  expect(context.user?.profileId).toBeNull();
  return createSuccessResponse(
{ 
  userId: context.user?.id,
  hasProfile: !!context.user?.profileId,
},
context.requestId
  );
});

const wrappedHandler = withAuth(handler, { authMode: 'required' });
const request = createMockRequest({
  headers: { Authorization: 'Bearer valid-token-no-profile' },
});

// Act
const response = await wrappedHandler(request);

// Assert
expect(response.status).toBe(200);
expect(handler).toHaveBeenCalled();

const jsonResponse = await response.json();
expect(jsonResponse.data).toEqual({
  userId: 'user-456',
  hasProfile: false,
});
  });

  test('should handle authentication service timeouts', async () => {
// Arrange - Simulate authentication service timeout
mockApiAuth.authenticateRequest.mockResolvedValue({
  user: null,
  error: {
code: 'TOKEN_VERIFICATION_FAILED',
message: 'Authentication service timeout',
  },
});

const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
const wrappedHandler = withAuth(handler, { authMode: 'required' });
const request = createMockRequest({
  headers: { Authorization: 'Bearer timeout-test-token' },
});

// Act
const response = await wrappedHandler(request);

// Assert
expect(response.status).toBe(401);
expect(handler).not.toHaveBeenCalled();

const jsonResponse = await response.json();
expect(jsonResponse).toMatchObject({
  success: false,
  error: {
code: 'TOKEN_VERIFICATION_FAILED',
message: 'Authentication service timeout',
requestId: expect.any(String),
timestamp: expect.any(String),
  },
});
  });

  test('should handle network errors during token verification', async () => {
// Arrange - Simulate network failure during token verification
mockApiAuth.authenticateRequest.mockRejectedValue(
  new Error('Network error: Connection refused to auth service')
);

const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
const wrappedHandler = withAuth(handler, { authMode: 'required' });
const request = createMockRequest({
  headers: { Authorization: 'Bearer network-error-token' },
});

// Act
const response = await wrappedHandler(request);

// Assert
expect(response.status).toBe(500);
expect(handler).not.toHaveBeenCalled();

const jsonResponse = await response.json();
expect(jsonResponse).toMatchObject({
  success: false,
  error: {
code: 'INTERNAL_SERVER_ERROR',
message: 'Internal server error occurred',
requestId: expect.any(String),
timestamp: expect.any(String),
  },
});

expect(consoleSpy).toHaveBeenCalledWith(
  expect.stringContaining('API Wrapper Error'),
  expect.objectContaining({
error: 'Network error: Connection refused to auth service',
  })
);

consoleSpy.mockRestore();
  });

  test('should validate performance with various token types', async () => {
// Arrange - Test performance with different token scenarios
const tokenScenarios = [
  {
name: 'valid-token',
mockResponse: {
  user: MOCK_USER,
  error: null,
},
expectedStatus: 200,
  },
  {
name: 'invalid-token',
mockResponse: {
  user: null,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'Invalid token',
  },
},
expectedStatus: 401,
  },
  {
name: 'expired-token',
mockResponse: {
  user: null,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'Token expired',
  },
},
expectedStatus: 401,
  },
  {
name: 'malformed-token',
mockResponse: {
  user: null,
  error: {
code: 'AUTHENTICATION_FAILED',
message: 'Malformed token',
  },
},
expectedStatus: 401,
  },
];

const handler = createTestHandler(createSuccessResponse({ test: 'perf' }, 'perf-req'));
const wrappedHandler = withAuth(handler, { authMode: 'required' });

for (const scenario of tokenScenarios) {
  // Arrange
  mockApiAuth.authenticateRequest.mockResolvedValue(scenario.mockResponse);

  const request = createMockRequest({
headers: { Authorization: `Bearer ${scenario.name}` },
  });

  // Act
  const startTime = performance.now();
  const response = await wrappedHandler(request);
  const endTime = performance.now();

  // Assert
  const processingTime = endTime - startTime;
  expect(processingTime).toBeLessThan(5); // Must stay under 5ms requirement
  expect(response.status).toBe(scenario.expectedStatus);
}
  });

  test('should handle Bearer token edge cases', async () => {
// Arrange - Test various Bearer token format edge cases
const bearerTokenEdgeCases = [
  { headers: {}, description: 'missing Authorization header' },
  { headers: { Authorization: '' }, description: 'empty Authorization header' },
  { headers: { Authorization: 'Bearer' }, description: 'Bearer without token' },
  { headers: { Authorization: 'Bearer ' }, description: 'Bearer with only space' },
  { headers: { Authorization: 'Basic token123' }, description: 'wrong auth scheme' },
  { headers: { Authorization: 'bearer lowercase-token' }, description: 'lowercase bearer' },
  { headers: { authorization: 'Bearer case-sensitive-header' }, description: 'lowercase header name' },
];

for (const testCase of bearerTokenEdgeCases) {
  mockApiAuth.authenticateRequest.mockResolvedValue({
user: null,
error: {
  code: 'AUTHENTICATION_REQUIRED',
  message: 'Invalid or missing authorization header',
},
  });

  const handler = createTestHandler(createSuccessResponse({}, 'test-req-id'));
  const wrappedHandler = withAuth(handler, { authMode: 'required' });
  const request = createMockRequest({
headers: testCase.headers,
  });

  // Act
  const response = await wrappedHandler(request);

  // Assert
  expect(response.status).toBe(401);
  expect(handler).not.toHaveBeenCalled();

  const jsonResponse = await response.json();
  expect(jsonResponse.success).toBe(false);
  expect(jsonResponse.error.code).toBe('AUTHENTICATION_REQUIRED');
}
  });
});

describe('Integration Tests', () => {
  beforeEach(() => {
jest.clearAllMocks();
  });

  test('should maintain sub-5ms performance requirement', async () => {
// Arrange
const mockApiAuth = apiAuth as jest.Mocked<typeof apiAuth>;

// Mock fast authentication response (simulate sub-1ms auth)
mockApiAuth.authenticateRequest.mockImplementation(async () => {
  await new Promise(resolve => setTimeout(resolve, 1)); // 1ms delay
  return {
user: {
  id: 'user-perf-test',
  email: 'perf@test.com',
  profileId: 'profile-perf',
},
error: null,
  };
});

const handler = createTestHandler(createSuccessResponse({ test: 'perf' }, 'perf-req'));
const wrappedHandler = withAuth(handler, { authMode: 'required' });
const request = new NextRequest('http://localhost:3000/api/test', {
  headers: { Authorization: 'Bearer perf-token' },
});

// Act
const startTime = Date.now();
const response = await wrappedHandler(request);
const endTime = Date.now();

// Assert
const totalTime = endTime - startTime;
expect(totalTime).toBeLessThan(5); // Performance requirement: <5ms
expect(response.status).toBe(200);
  });

  test('should handle concurrent requests without conflicts', async () => {
// Arrange
const mockApiAuth = apiAuth as jest.Mocked<typeof apiAuth>;

mockApiAuth.authenticateRequest.mockImplementation(async (headers) => {
  const authHeader = headers.get?.('authorization') || '';
  const token = authHeader.replace('Bearer ', '');
  
  return {
user: {
  id: `user-${token}`,
  email: `${token}@test.com`,
  profileId: `profile-${token}`,
},
error: null,
  };
});

const handler = jest.fn(async (req: NextRequest, context: AuthenticatedContext) => {
  return createSuccessResponse(
{ 
  userId: context.user?.id,
  requestId: context.requestId,
},
context.requestId
  );
});

const wrappedHandler = withAuth(handler, { authMode: 'required' });

// Act - Create 10 concurrent requests
const requests = Array.from({ length: 10 }, (_, i) => {
  return new NextRequest('http://localhost:3000/api/concurrent', {
headers: { Authorization: `Bearer token-${i}` },
  });
});

const responses = await Promise.all(
  requests.map(req => wrappedHandler(req))
);

// Assert
expect(responses).toHaveLength(10);

// Verify all responses are successful
for (const response of responses) {
  expect(response.status).toBe(200);
}

// Verify all responses have unique request IDs and correct user data
const jsonResponses = await Promise.all(
  responses.map(r => r.json())
);

const requestIds = jsonResponses.map(r => r.requestId);
const uniqueRequestIds = new Set(requestIds);
expect(uniqueRequestIds.size).toBe(10); // All request IDs should be unique

// Verify user data matches token
jsonResponses.forEach((json, index) => {
  expect(json.data.userId).toBe(`user-token-${index}`);
});
  });

  test('should integrate properly with real NextRequest objects', async () => {
// Arrange
const mockApiAuth = apiAuth as jest.Mocked<typeof apiAuth>;

mockApiAuth.authenticateRequest.mockResolvedValue({
  user: {
id: 'integration-user',
email: 'integration@test.com',
profileId: 'integration-profile',
  },
  error: null,
});

const handler = jest.fn(async (req: NextRequest, context: AuthenticatedContext) => {
  // Verify we can access all NextRequest properties
  expect(req.method).toBe('POST');
  expect(req.url).toBe('http://localhost:3000/api/integration');
  expect(req.headers.get('content-type')).toBe('application/json');
  
  return createSuccessResponse(
{
  method: req.method,
  url: req.url,
  hasBody: req.body !== null,
  user: context.user?.email,
},
context.requestId
  );
});

const wrappedHandler = withAuth(handler, { authMode: 'required' });

// Create a real NextRequest with all typical properties
const request = new NextRequest('http://localhost:3000/api/integration', {
  method: 'POST',
  headers: {
'Content-Type': 'application/json',
'Authorization': 'Bearer integration-token',
'User-Agent': 'Integration-Test/1.0',
  },
  body: JSON.stringify({ test: 'data' }),
});

// Act
const response = await wrappedHandler(request);

// Assert
expect(response.status).toBe(200);

const jsonResponse = await response.json();
expect(jsonResponse).toMatchObject({
  success: true,
  data: {
method: 'POST',
url: 'http://localhost:3000/api/integration',
hasBody: true,
user: 'integration@test.com',
  },
  requestId: expect.any(String),
  timestamp: expect.any(String),
});

// Verify handler was called with correct parameters
expect(handler).toHaveBeenCalledWith(
  request,
  expect.objectContaining({
user: expect.objectContaining({
  id: 'integration-user',
  email: 'integration@test.com',
}),
isAuthenticated: true,
requestId: expect.any(String),
timestamp: expect.any(String),
  })
);
  });
});